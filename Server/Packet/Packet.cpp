#include "Packet.h"


Server::cPacket::cPacket()
{
	mRecvBuf.Reset_Buffer(0);
}

Server::cPacket::~cPacket()
{	
	while(mSendBuf.LockSize() > 0)
	{
		Utilities::sBuffer* empt = mSendBuf.LockFront();
		mSendBuf.LockPop();
		delete empt;
	}
}

bool Server::cPacket::IsPacking()
{
	return (mSendBuf.LockSize() > 0);
}

void Server::cPacket::Init_Recv_Overlap()
{
	ZeroMemory(&mRecvOverlap.overlapped, sizeof(mRecvOverlap.overlapped));
	mRecvOverlap.wsabuf.buf = (char*)(mRecvBuf.mByte + mRecvBuf.mTrans);
	mRecvOverlap.wsabuf.len = mRecvBuf.mSize - mRecvBuf.mTrans;
}

void Server::cPacket::Init_Send_Overlap()
{
	Utilities::sBuffer* sendBuf = mSendBuf.LockFront();
	ZeroMemory(&mSendOverlap.overlapped, sizeof(mSendOverlap.overlapped));
	mSendOverlap.wsabuf.buf = (char*)(sendBuf->mByte + sendBuf->mTrans);
	mSendOverlap.wsabuf.len = sendBuf->mSize - sendBuf->mTrans;
}

bool Server::cPacket::Is_Recv_Overlap(LPOVERLAPPED _overlap)
{
	return (&(mRecvOverlap.overlapped) == _overlap);
}

bool Server::cPacket::Is_Send_Overlap(LPOVERLAPPED _overlap)
{
	return  (&(mSendOverlap.overlapped) == _overlap);
}

bool Server::cPacket::Is_Recv_Success(DWORD _trans)
{
	mRecvBuf.mTrans += _trans;
	if (mRecvBuf.mSize == mRecvBuf.mTrans)//현재 받은데이터와 총 받을 데이터가 같을시
	{
		return true;//데이터 수신 완료 리턴
	}
	return false;//데이터 수신 진행중 리턴
}

bool Server::cPacket::Is_Send_Success(DWORD _trans)
{
	mSendBuf.LockFront()->mTrans += _trans;
	if (mSendBuf.LockFront()->mSize == mSendBuf.LockFront()->mTrans)//현재 송신데이터와 총 데이터의 크기가 같을시
	{
		//큐에서 데이터를 뺌
		Utilities::sBuffer* empt = mSendBuf.LockFront();
		mSendBuf.LockPop();
		return true;//데이터 송신 완료 리턴
	}
	return false;//데이터 송신 진행중 리턴
}

void Server::cPacket::Set_Recv_Size(int _size)
{
	mRecvBuf.Reset_Buffer(_size);
}

int Server::cPacket::Get_Recv_Size()
{
	return mRecvBuf.mSize;
}

int Server::cPacket::Get_Recv_Trans()
{
	return mRecvBuf.mTrans;
}

void Server::cPacket::Send_Packet_Push(Utilities::sBuffer* _buffer)
{
	mSendBuf.LockPush(_buffer);
}
